# Краткая справка по языку SLang (**S**emantic **Lang**uage)
## Простая программа
Вывод сообщения "Hello, World!"
```
module Main
start
    output "Hello, World!";
end
```
## Типы языка
* Скалярные
  * Встроенные типы:
    * ```integer``` — целые 64-битные знаковые числа
    * ```real``` — вещественные 64-битные знаковые числа
    * ```character``` — символ (1 байт)
    * ```string``` — строка символов, содержит специальный символ окончания строки
    * ```boolean``` — булево значение (истина или ложь)
  * Типы, определенные пользователем (см. описание классов)
  * Указатели, на типы, определенные пользователем
* Массивы
## Основные операторы
### Модуль
Каждый файл должен содержать только один модуль с таким же именем, как и файл (расширение не считается). Файл с кодом на языке SLang должен иметь расширение .sl. Имя модуля должно являться верным идентификатором языка (начинается со знака подчеркивания или латиницы, следующие символы — латиница, цифры или знак подчеркивания)

Главный модуль программы должен иметь название Main (имя файла соответственно Main.sl). Главный модуль должен иметь блок ```start-end```, в котором находится логика программы. Общая схема программы приведена в листинге:
```
// импорты (могут не быть)
import Foo
// директива модуля (обязательна)
module modulename
// объявления (могут не быть)
public variable integer a := 1234;
// блок start-end, если модуль главный
start
end
```
### Оператор ```import```
Импорт модуля, который может находится в системной папке (стандартная библиотека языка, описание которой приведено в соответствующем документе), а также в папке с главным модулем (вложенные директории не считаются)

В случае конфликта пользовательского модуля с системным (совпадают имена) должно выводиться сообщение об ошибке
### Объявления переменных и констант
Важно: имя переменной/константы должно быть валидным идентификатором (об этом написано выше) и не перекрывать переменные из своей области видимости (в том числе, названия функций, процедур и полей модуля)

Важно отметить, что в языке все объявления происходят по одному принципу — ключевое слово-тип-название. Данная схема применяется и для процедур с функциями.
Примеры: 
* Переменные 
  * (`variable` только для встроенных скалярных типов и типов, определенных пользователем)
    * `variable integer MyIntVar;` 
    * `variable System.Object myObject;`
  * Массивы
    * `array[1][2] integer MyArray;` // не может быть константой, константы только для скалярных типов, элемент массива — скалярного типа
  * Указатели
    * `pointer(System.Object) MyPtr;` // объявление указателя
* Константы (только для скалярных типов)
  * `const integer MyIntConst := 1;` // константы всегда должны иметь значение
  * `const pointer(System.Object) MyPtr := nil;` // константа-указатель
  * `const System.Object myObject;`


Отметим, что неявных преобразований типов в языке нет, поэтому сужающие и прочие преобразования запрещены, не считая случаев принципа подстановки, когда переменной или константе базового типа (или указателя на неё), определенного пользователем, присваивается более частный тип

### Присваивание значения 
``` 
let a := 123;
let b.field := "Hello";
let b[10][123].field = 1.0e-12;
```
### Операторы ввода и вывода
```
// Ввод и вывод только для встроенных скалярных типов!
input a, b.field, c[10];
output 123, a, b.field, '-', "Hello World", 0.12, c[10], 123+123;
```
### Вызов процедур
```
call Core.Pause(); // pause program
```
Только для процедур!
### Блочные операторы
#### Условный оператор
```
// Выражения должны иметь тип boolean!
if ((first == 42) && (second == 42)) then
    output "first == second == 42!\n";
end

if (first == second) then
    output "first and second are the same!\n";
else
    output "first and second are not the same!\n";
end

if (first > second) then
    output "first is more than second\n";
elseif (first < second) then
    output "first is less than second\n";
else
    output "first and second are the same\n";
end
```
#### Циклы с предусловием
```
variable integer i := 0;
while (i < n) do
    output "*";
    let i := i + 1;
end
```
#### Циклы с постусловием
```
variable integer j := 0;
repeat
    output "*";
    let j := j + 1;
while (j < n)
```
### Выражения
#### Арифметические операции
* Операторы +, - (унарные и бинарные), *, /, % (остаток от деления, только для целых чисел)
* Только для целых и дробных чисел, причем оба операнда должны быть одного и того же типа
#### Операторы сравнения
* Операторы >=, <=, ==, !=, >, <
* Сравнить можно:
  * int и float и char и bool только между собой — все простые типы кроме строк
  * Указатели любого типа только между собой
#### Булевы операторы
* &&, ||, !
* Только для булевых значений
#### Приоритет
Приоритет операций близок к паскалевским, простой пример:

```((first == 42) && (second == 42))``` — скомпилируется

```(first == 42 && second == 42)``` — нет

#### Особые значения и функции для указателей
* `nil` — пустой указатель
* ```new(название класса)``` — выделение памяти для заданного типа

Операция `delete` для указателей отсутствует, освобождение памяти происходит при выходе из блока, где указатель объявлен (при трансляции C++ используются умные указатели).

Не рекомендуется допускать циклических ссылок при работе с указателями.

## Сложные операторы
### Функции и процедуры
```
public function(val integer arg): integer test // public значит доступно из других модулей
    return arg * 2;
end

private procedure(val integer temp) valuePass // недоступно из других модулей
    let temp := temp + 1;
end

public procedure(ref integer temp) refPass // параметр передается по ссылке, а не по значению
    let temp := temp + 1;
end
```
* ```val``` — параметр передается по значению, т.е он не будет изменен после вызова процедуры/функции, можно передавать выражения
* ```ref``` — параметр передается по ссылке, передавать можно переменные, поля переменных (если сложный тип), элементы массивов
### Возврат значения из функций
```
return <выражение>;
```

Выражение в `return` должно соответствовать возвращаемому типу (для встроенных типов, для классов и указателей все аналогично принципу подстановки)

### Классы
Пример простого класса
```
public base class Base // Помечен как base — значит можно отнаследоваться
    // открытое поле, видно извне класса и внутри наследников
    public variable integer myField; // объявления как у простых переменных, только должен быть модификатор
    // закрытое поле, видно только внутри методов класс
    private variable integer myPrivateField;
end
```

Конструкторов и деструкторов в языке нет!

Наследование
```
public class Derived inherit(Base) // класс Base должен быть помечен модификатором base
end
```
### Методы классов

Методы объявляются вне классов и обязательно в том же модуле, где и объявлен сам класс!
Объявление методов не отличается от объявления функций и процедур, не считая блока типа (указывающего какого класса данный метод и именование ссылки на экземпляр этого класса (аналог this в Java, C++, C#, т.д.))

```
// пример метода-функции (методы-процедуры тоже работают)
public (Base b) function (): integer myMethod // как и обычная функция, только до слова function идет блок типа 
    // (Base b) — метод относится к типу Base, его экземпляр имеет имя b
    let b.myField := 42;
    return b.myField;
end
```
Абстрактный метод
```
// Объявление типа для наглядности
public base class AbstractDemo
end

public abstract (AbstractDemo d) procedure () Demo 
end
```
Перегрузка методов (как обычных, так и абстрактных) в производном классе
```
public class NotAbstract inherit(AbstractDemo)
end

public override (NotAbstract obj) procedure () Demo
    output "Hello, World!";
end
```
### Поля модуля
```
module SomeModule
// правила объявления такие же как у обычных переменных, только добавляется модификатор доступа
public variable integer A; // открытая переменная
private const real B := 1.0; // закрытая константа
```
## Дополнительно
Для тех, кто хочет писать свои либы для SLang (смотрите исходники стандартной библиотеки)
### Атрибут ```[from ... import ...]```
```
[from "CppLib/Files_cpp.hpp" import "Files_cpp::open"] // Папка CppLib находится в директории компилятора
public function(val string path, val character options): File Open
end
```

Теперь в других модулях вызов данной функции будет заменяться на вызов Files_cpp::open из соответствующего файла

Атрибут работает также для процедур и полей/констант модуля (значение при инициализации для констант при этом будет игнорироваться)
### "Пустые" модули (```empty```) и классы
```
empty module Files

	[from "CppLib/Files_cpp.hpp" import "Files_cpp::file_stream"]
	public empty class File;
```

Пустой модуль — не транслируется в файлы целевого языка! При импорте такого модуля будут собраны все необходимые импорты у его элементов (пустых классов, импортируемых функций и процедур, а также полей)

Пустой класс — это подстановка некого класса, реализованного на целевом ЯП (в нашем случае, С++), от таких классов нельзя отнаследоваться! 